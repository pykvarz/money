import 'dart:async';
import 'package:flutter/services.dart';
import '../models/transaction.dart';
import '../models/notification_rule.dart';
import '../models/notification_log.dart';
import 'database_helper.dart';

class NotificationParserService {
  static const platform = MethodChannel('com.expensebook.expense_book/notification_parser');
  
  final DatabaseHelper _db;
  final Function(Transaction) onTransactionCreated;

  NotificationParserService({
    required DatabaseHelper db,
    required this.onTransactionCreated,
  }) : _db = db {
    _setupMethodChannel();
  }

  void _setupMethodChannel() {
    platform.setMethodCallHandler((call) async {
      if (call.method == 'onNotificationReceived') {
        final packageName = call.arguments['packageName'] as String;
        final text = call.arguments['text'] as String;
        
        await handleNotification(packageName, text);
      }
    });
  }

  // Parse and create transaction from notification
  Future<void> handleNotification(String packageName, String text) async {
    String? parsedAmount;
    String? parsedKeyword;
    bool parseSuccess = false;
    
    try {
      final parsed = _parseNotificationText(text);
      
      if (parsed != null) {
        parsedAmount = parsed.amount.toString();
        parsedKeyword = parsed.keyword;
        parseSuccess = true;
        
        // Get category for keyword
        final categoryId = _db.getCategoryForKeyword(parsed.keyword);
        
        if (categoryId != null) {
          // Create transaction
          final transaction = Transaction(
            id: '', // Will be auto-generated by UUID in provider
            categoryId: categoryId,
            amount: parsed.amount,
            note: parsed.keyword,
            date: DateTime.now(),
            createdAt: DateTime.now(),
            type: TransactionType.expense,
          );

          await _db.addTransaction(transaction);
          onTransactionCreated(transaction);
          
          print('Auto-created transaction: ${parsed.amount} KZT for ${parsed.keyword}');
        } else {
          print('No category mapped for keyword: ${parsed.keyword}');
        }
      } else {
        print('Failed to parse notification: $text');
      }
    } catch (e) {
      print('Error handling notification: $e');
      parseSuccess = false;
    } finally {
      // Always log the notification for debugging
      await _saveNotificationLog(
        packageName: packageName,
        text: text,
        parsedAmount: parsedAmount,
        parsedKeyword: parsedKeyword,
        parseSuccess: parseSuccess,
      );
    }
  }

  Future<void> _saveNotificationLog({
    required String packageName,
    required String text,
    String? parsedAmount,
    String? parsedKeyword,
    required bool parseSuccess,
  }) async {
    final log = NotificationLog(
      packageName: packageName,
      text: text,
      timestamp: DateTime.now(),
      parsedAmount: parsedAmount,
      parsedKeyword: parsedKeyword,
      parseSuccess: parseSuccess,
    );
    await _db.addNotificationLog(log);
  }

  // Parse notification text
  _ParsedNotification? _parseNotificationText(String text) {
    // Format: "покупка: 1000.00KZT\nSUPERMARKET\nДоступно: 5000.00KZT"
    
    // Regex to extract amount and keyword
    final regex = RegExp(
      r'покупка:\s*(\d+(?:\.\d+)?)\s*KZT\s*\n\s*(.+?)(?:\n|$)',
      caseSensitive: false,
      multiLine: true,
    );

    final match = regex.firstMatch(text);
    
    if (match == null) {
      return null;
    }

    final amountStr = match.group(1);
    final keyword = match.group(2)?.trim();

    if (amountStr == null || keyword == null) {
      return null;
    }

    return _ParsedNotification(
      amount: double.parse(amountStr),
      keyword: keyword.toUpperCase(),
    );
  }

  // Method channel utilities
  static Future<void> setBankEnabled(String packageName, bool enabled) async {
    try {
      await platform.invokeMethod('setBankEnabled', {
        'packageName': packageName,
        'enabled': enabled,
      });
    } catch (e) {
      print('Error setting bank enabled: $e');
    }
  }

  static Future<bool> isBankEnabled(String packageName) async {
    try {
      final result = await platform.invokeMethod('isBankEnabled', {
        'packageName': packageName,
      });
      return result as bool;
    } catch (e) {
      print('Error checking bank enabled: $e');
      return false;
    }
  }

  static Future<List<String>> getCustomBanks() async {
    try {
      final result = await platform.invokeMethod('getCustomBanks');
      if (result == null || result.isEmpty) {
        return [];
      }
      return List<String>.from(result.split(','));
    } catch (e) {
      print('Error getting custom banks: $e');
      return [];
    }
  }

  static Future<void> addCustomBank(String packageName) async {
    try {
      await platform.invokeMethod('addCustomBank', {
        'packageName': packageName,
      });
    } catch (e) {
      print('Error adding custom bank: $e');
    }
  }

  static Future<void> removeCustomBank(String packageName) async {
    try {
      await platform.invokeMethod('removeCustomBank', {
        'packageName': packageName,
      });
    } catch (e) {
      print('Error removing custom bank: $e');
    }
  }

  static Future<void> openNotificationSettings() async {
    try {
      await platform.invokeMethod('openNotificationSettings');
    } catch (e) {
      print('Error opening notification settings: $e');
    }
  }
}

class _ParsedNotification {
  final double amount;
  final String keyword;

  _ParsedNotification({
    required this.amount,
    required this.keyword,
  });
}
