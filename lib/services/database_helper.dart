import 'package:hive_flutter/hive_flutter.dart';
import 'package:uuid/uuid.dart';
import '../models/transaction.dart';
import '../models/category.dart';
import '../models/weekly_limit.dart';
import '../models/monthly_limit.dart';
import '../models/monthly_budget.dart';
import '../models/fixed_expense.dart';

class DatabaseHelper {
  static const String _transactionsBox = 'transactions';
  static const String _categoriesBox = 'categories';
  static const String _weeklyLimitsBox = 'weeklyLimits';
  static const String _monthlyLimitsBox = 'monthlyLimits';
  static const String _monthlyBudgetsBox = 'monthlyBudgets';
  static const String _fixedExpensesBox = 'fixedExpenses';

  final _uuid = const Uuid();

  // Singleton pattern
  static final DatabaseHelper _instance = DatabaseHelper._internal();
  factory DatabaseHelper() => _instance;
  DatabaseHelper._internal();

  // Initialize Hive and register adapters
  Future<void> init() async {
    await Hive.initFlutter();

    // Register adapters (generated by build_runner)
    Hive.registerAdapter(TransactionAdapter());
    Hive.registerAdapter(TransactionTypeAdapter());
    Hive.registerAdapter(CategoryAdapter());
    Hive.registerAdapter(CategoryTypeAdapter());
    Hive.registerAdapter(WeeklyLimitAdapter());
    Hive.registerAdapter(MonthlyBudgetAdapter());
    Hive.registerAdapter(MonthlyLimitAdapter());
    Hive.registerAdapter(FixedExpenseAdapter());

    // Open boxes
    await Hive.openBox<Transaction>(_transactionsBox);
    await Hive.openBox<Category>(_categoriesBox);
    await Hive.openBox<WeeklyLimit>(_weeklyLimitsBox);
    await Hive.openBox<MonthlyLimit>(_monthlyLimitsBox);
    await Hive.openBox<MonthlyBudget>(_monthlyBudgetsBox);
    await Hive.openBox<FixedExpense>(_fixedExpensesBox);

    // Seed default categories if empty
    await _seedDefaultCategories();
  }

  // Seed default categories on first launch
  Future<void> _seedDefaultCategories() async {
    final categoryBox = Hive.box<Category>(_categoriesBox);
    if (categoryBox.isEmpty) {
      final defaultCategories = Category.getDefaultCategories();
      for (var category in defaultCategories) {
        await categoryBox.put(category.id, category);
      }
    }
  }

  // ==================== CATEGORY OPERATIONS ====================

  Future<void> addCategory(Category category) async {
    final box = Hive.box<Category>(_categoriesBox);
    await box.put(category.id, category);
  }

  Future<void> updateCategory(Category category) async {
    await addCategory(category); // Hive uses same method for update
  }

  Future<void> deleteCategory(String id) async {
    final box = Hive.box<Category>(_categoriesBox);
    await box.delete(id);
  }

  Category? getCategoryById(String id) {
    final box = Hive.box<Category>(_categoriesBox);
    return box.get(id);
  }

  List<Category> getAllCategories() {
    final box = Hive.box<Category>(_categoriesBox);
    return box.values.toList();
  }

  List<Category> getCategoriesByType(CategoryType type) {
    final box = Hive.box<Category>(_categoriesBox);
    return box.values.where((cat) => cat.type == type).toList();
  }

  // ==================== TRANSACTION OPERATIONS ====================

  Future<String> addTransaction(Transaction transaction) async {
    final box = Hive.box<Transaction>(_transactionsBox);
    await box.put(transaction.id, transaction);
    return transaction.id;
  }

  Future<void> updateTransaction(Transaction transaction) async {
    await addTransaction(transaction);
  }

  Future<void> deleteTransaction(String id) async {
    final box = Hive.box<Transaction>(_transactionsBox);
    await box.delete(id);
  }

  Transaction? getTransactionById(String id) {
    final box = Hive.box<Transaction>(_transactionsBox);
    return box.get(id);
  }

  List<Transaction> getAllTransactions() {
    final box = Hive.box<Transaction>(_transactionsBox);
    return box.values.toList();
  }

  // Get transactions for a specific month
  List<Transaction> getTransactionsForMonth(int month, int year) {
    final box = Hive.box<Transaction>(_transactionsBox);
    return box.values
        .where((txn) => txn.isInMonth(month, year))
        .toList()
      ..sort((a, b) => b.date.compareTo(a.date)); // Latest first
  }

  // Get transactions for current week for a specific category
  List<Transaction> getCurrentWeekTransactions(String categoryId) {
    final box = Hive.box<Transaction>(_transactionsBox);
    final now = DateTime.now();
    final weekStart = _getWeekStart(now);
    final weekEnd = weekStart.add(const Duration(days: 7));

    return box.values
        .where((txn) =>
            txn.categoryId == categoryId &&
            txn.date.isAfter(weekStart.subtract(const Duration(seconds: 1))) &&
            txn.date.isBefore(weekEnd))
        .toList();
  }

  // Helper to get Monday of current week
  DateTime _getWeekStart(DateTime date) {
    final weekday = date.weekday;
    return DateTime(date.year, date.month, date.day - (weekday - 1));
  }

  // ==================== MONTHLY BUDGET OPERATIONS ====================

  Future<void> addMonthlyBudget(MonthlyBudget budget) async {
    final box = Hive.box<MonthlyBudget>(_monthlyBudgetsBox);
    await box.put(budget.id, budget);
  }

  Future<void> updateMonthlyBudget(MonthlyBudget budget) async {
    await addMonthlyBudget(budget);
  }

  Future<void> deleteMonthlyBudget(String id) async {
    final box = Hive.box<MonthlyBudget>(_monthlyBudgetsBox);
    await box.delete(id);
  }

  MonthlyBudget? getMonthlyBudgetById(String id) {
    final box = Hive.box<MonthlyBudget>(_monthlyBudgetsBox);
    return box.get(id);
  }

  // Get or create monthly budget for a specific month
  Future<MonthlyBudget> getOrCreateMonthlyBudget(int month, int year) async {
    final box = Hive.box<MonthlyBudget>(_monthlyBudgetsBox);
    
    // Try to find existing budget
    final existing = box.values.firstWhere(
      (budget) => budget.month == month && budget.year == year,
      orElse: () => MonthlyBudget(
        id: '',
        month: 0,
        year: 0,
        createdAt: DateTime.now(),
      ),
    );

    if (existing.id.isNotEmpty) {
      return existing;
    }

    // Create new budget for this month
    final fixedExpensesTotal = getTotalFixedExpensesForMonth();
    
    final newBudget = MonthlyBudget(
      id: _uuid.v4(),
      month: month,
      year: year,
      initialBalance: 0.0,
      createdAt: DateTime.now(),
      projectedFixedExpenses: fixedExpensesTotal,
    );

    await addMonthlyBudget(newBudget);
    return newBudget;
  }

  List<MonthlyBudget> getAllMonthlyBudgets() {
    final box = Hive.box<MonthlyBudget>(_monthlyBudgetsBox);
    return box.values.toList()
      ..sort((a, b) {
        final dateA = DateTime(a.year, a.month);
        final dateB = DateTime(b.year, b.month);
        return dateB.compareTo(dateA); // Latest first
      });
  }

  // ==================== WEEKLY LIMIT OPERATIONS ====================

  Future<void> addWeeklyLimit(WeeklyLimit limit) async {
    final box = Hive.box<WeeklyLimit>(_weeklyLimitsBox);
    await box.put(limit.id, limit);
  }

  Future<void> updateWeeklyLimit(WeeklyLimit limit) async {
    await addWeeklyLimit(limit);
  }

  Future<void> deleteWeeklyLimit(String id) async {
    final box = Hive.box<WeeklyLimit>(_weeklyLimitsBox);
    await box.delete(id);
  }

  WeeklyLimit? getWeeklyLimitById(String id) {
    final box = Hive.box<WeeklyLimit>(_weeklyLimitsBox);
    return box.get(id);
  }

  List<WeeklyLimit> getAllWeeklyLimits() {
    final box = Hive.box<WeeklyLimit>(_weeklyLimitsBox);
    return box.values.toList();
  }

  // Get active weekly limit for a category
  WeeklyLimit? getActiveWeeklyLimitForCategory(String categoryId) {
    final box = Hive.box<WeeklyLimit>(_weeklyLimitsBox);
    return box.values.firstWhere(
      (limit) => limit.categoryId == categoryId && limit.isActive && limit.isCurrentWeek(),
      orElse: () => WeeklyLimit(
        id: '',
        categoryId: '',
        limitAmount: 0,
        weekStartDate: DateTime.now(),
        isActive: false,
      ),
    ).id.isNotEmpty
        ? box.values.firstWhere(
            (limit) => limit.categoryId == categoryId && limit.isActive && limit.isCurrentWeek(),
          )
        : null;
  }

  // ==================== MONTHLY LIMIT OPERATIONS ====================

  Future<void> addMonthlyLimit(MonthlyLimit limit) async {
    final box = Hive.box<MonthlyLimit>(_monthlyLimitsBox);
    await box.put(limit.id, limit);
  }

  Future<void> updateMonthlyLimit(MonthlyLimit limit) async {
    await addMonthlyLimit(limit);
  }

  Future<void> deleteMonthlyLimit(String id) async {
    final box = Hive.box<MonthlyLimit>(_monthlyLimitsBox);
    await box.delete(id);
  }

  MonthlyLimit? getMonthlyLimitById(String id) {
    final box = Hive.box<MonthlyLimit>(_monthlyLimitsBox);
    return box.get(id);
  }

  List<MonthlyLimit> getAllMonthlyLimits() {
    final box = Hive.box<MonthlyLimit>(_monthlyLimitsBox);
    return box.values.toList();
  }

  // Get active monthly limit for a category
  MonthlyLimit? getActiveMonthlyLimitForCategory(String categoryId) {
    final box = Hive.box<MonthlyLimit>(_monthlyLimitsBox);
    try {
      return box.values.firstWhere(
        (limit) => limit.categoryId == categoryId && limit.isActive,
      );
    } catch (_) {
      return null;
    }
  }

  // ==================== ANALYTICS HELPERS ====================

  // Calculate total income for a month
  double getTotalIncomeForMonth(int month, int year) {
    final transactions = getTransactionsForMonth(month, year);
    return transactions
        .where((txn) => txn.type == TransactionType.income)
        .fold(0.0, (sum, txn) => sum + txn.amount);
  }

  // Calculate total expense for a month
  double getTotalExpenseForMonth(int month, int year) {
    final transactions = getTransactionsForMonth(month, year);
    return transactions
        .where((txn) => txn.type == TransactionType.expense)
        .fold(0.0, (sum, txn) => sum + txn.amount);
  }

  // Calculate current balance for a month
  double getCurrentBalanceForMonth(int month, int year, double initialBalance) {
    final income = getTotalIncomeForMonth(month, year);
    final expense = getTotalExpenseForMonth(month, year);
    return initialBalance + income - expense;
  }

  // Get spending by category for a month
  Map<String, double> getSpendingByCategory(int month, int year) {
    final transactions = getTransactionsForMonth(month, year)
        .where((txn) => txn.type == TransactionType.expense);
    
    final Map<String, double> categorySpending = {};
    for (var txn in transactions) {
      categorySpending[txn.categoryId] = (categorySpending[txn.categoryId] ?? 0) + txn.amount;
    }
    return categorySpending;
  }

  // ==================== FIXED EXPENSE OPERATIONS ====================

  Future<void> addFixedExpense(FixedExpense expense) async {
    final box = Hive.box<FixedExpense>(_fixedExpensesBox);
    await box.put(expense.id, expense);
  }

  Future<void> updateFixedExpense(FixedExpense expense) async {
    await addFixedExpense(expense);
  }

  Future<void> deleteFixedExpense(String id) async {
    final box = Hive.box<FixedExpense>(_fixedExpensesBox);
    await box.delete(id);
  }

  FixedExpense? getFixedExpenseById(String id) {
    final box = Hive.box<FixedExpense>(_fixedExpensesBox);
    return box.get(id);
  }

  List<FixedExpense> getAllFixedExpenses() {
    final box = Hive.box<FixedExpense>(_fixedExpensesBox);
    return box.values.where((expense) => expense.isActive).toList();
  }

  // Get total amount of fixed expenses for a month
  double getTotalFixedExpensesForMonth() {
    final expenses = getAllFixedExpenses();
    return expenses.fold(0.0, (sum,expense) => sum + expense.amount);
  }

  // ==================== CLEANUP ====================

  Future<void> close() async {
    await Hive.close();
  }
}
