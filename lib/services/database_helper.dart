import 'package:hive_flutter/hive_flutter.dart';
import 'package:uuid/uuid.dart';
import '../models/transaction.dart';
import '../models/category.dart';
import '../models/weekly_limit.dart';
import '../models/monthly_limit.dart';
import '../models/monthly_budget.dart';
import '../models/fixed_expense.dart';
import '../models/transaction_template.dart';
import '../models/savings_goal.dart';
import '../models/notification_rule.dart';
import '../models/notification_log.dart';


class DatabaseHelper {
  static const String _transactionsBox = 'transactions';
  static const String _categoriesBox = 'categories';
  static const String _weeklyLimitsBox = 'weeklyLimits';
  static const String _monthlyLimitsBox = 'monthlyLimits';
  static const String _monthlyBudgetsBox = 'monthlyBudgets';
  static const String _fixedExpensesBox = 'fixedExpenses';
  static const String _fixedExpensesStatusBox = 'fixedExpensesStatus';
  static const String _transactionTemplatesBox = 'transactionTemplates';
  static const String _savingsGoalsBox = 'savingsGoals';
  static const String _notificationRulesBox = 'notificationRules';
  static const String _notificationLogsBox = 'notificationLogs';

  static const String _settingsBox = 'settings';

  final _uuid = const Uuid();

  // Singleton pattern
  static final DatabaseHelper _instance = DatabaseHelper._internal();
  factory DatabaseHelper() => _instance;
  DatabaseHelper._internal();

  // Initialize Hive and register adapters
  Future<void> init() async {
    await Hive.initFlutter();

    // Register adapters (generated by build_runner)
    // Register adapters consistently with checks
    if (!Hive.isAdapterRegistered(TransactionAdapter().typeId)) {
      Hive.registerAdapter(TransactionAdapter());
    }
    if (!Hive.isAdapterRegistered(TransactionTypeAdapter().typeId)) {
      Hive.registerAdapter(TransactionTypeAdapter());
    }
    if (!Hive.isAdapterRegistered(CategoryAdapter().typeId)) {
      Hive.registerAdapter(CategoryAdapter());
    }
    if (!Hive.isAdapterRegistered(CategoryTypeAdapter().typeId)) {
      Hive.registerAdapter(CategoryTypeAdapter());
    }
    if (!Hive.isAdapterRegistered(WeeklyLimitAdapter().typeId)) {
      Hive.registerAdapter(WeeklyLimitAdapter());
    }
    if (!Hive.isAdapterRegistered(MonthlyBudgetAdapter().typeId)) {
      Hive.registerAdapter(MonthlyBudgetAdapter());
    }
    if (!Hive.isAdapterRegistered(MonthlyLimitAdapter().typeId)) {
      Hive.registerAdapter(MonthlyLimitAdapter());
    }
    if (!Hive.isAdapterRegistered(FixedExpenseAdapter().typeId)) {
      Hive.registerAdapter(FixedExpenseAdapter());
    }
    if (!Hive.isAdapterRegistered(TransactionTemplateAdapter().typeId)) {
      Hive.registerAdapter(TransactionTemplateAdapter());
    }
    if (!Hive.isAdapterRegistered(SavingsGoalAdapter().typeId)) {
      Hive.registerAdapter(SavingsGoalAdapter());
    }
    if (!Hive.isAdapterRegistered(NotificationRuleAdapter().typeId)) {
      Hive.registerAdapter(NotificationRuleAdapter());
    }
    if (!Hive.isAdapterRegistered(NotificationLogAdapter().typeId)) {
      Hive.registerAdapter(NotificationLogAdapter());
    }


    // Open boxes (safe to call multiple times, returns existing box if open)
    if (!Hive.isBoxOpen(_transactionsBox)) await Hive.openBox<Transaction>(_transactionsBox);
    if (!Hive.isBoxOpen(_categoriesBox)) await Hive.openBox<Category>(_categoriesBox);
    if (!Hive.isBoxOpen(_weeklyLimitsBox)) await Hive.openBox<WeeklyLimit>(_weeklyLimitsBox);
    if (!Hive.isBoxOpen(_monthlyLimitsBox)) await Hive.openBox<MonthlyLimit>(_monthlyLimitsBox);
    if (!Hive.isBoxOpen(_monthlyBudgetsBox)) await Hive.openBox<MonthlyBudget>(_monthlyBudgetsBox);
    if (!Hive.isBoxOpen(_fixedExpensesBox)) await Hive.openBox<FixedExpense>(_fixedExpensesBox);
    if (!Hive.isBoxOpen(_fixedExpensesStatusBox)) await Hive.openBox(_fixedExpensesStatusBox);
    if (!Hive.isBoxOpen(_transactionTemplatesBox)) await Hive.openBox<TransactionTemplate>(_transactionTemplatesBox);
    if (!Hive.isBoxOpen(_savingsGoalsBox)) await Hive.openBox<SavingsGoal>(_savingsGoalsBox);
    if (!Hive.isBoxOpen(_notificationRulesBox)) await Hive.openBox<NotificationRule>(_notificationRulesBox);
    if (!Hive.isBoxOpen(_notificationLogsBox)) await Hive.openBox<NotificationLog>(_notificationLogsBox);

    if (!Hive.isBoxOpen(_settingsBox)) await Hive.openBox(_settingsBox);

    // Seed default categories and rules if empty
    await _seedDefaultCategories();
    await _seedDefaultNotificationRules();
  }

  // Seed default categories on first launch
  Future<void> _seedDefaultCategories() async {
    final categoryBox = Hive.box<Category>(_categoriesBox);
    if (categoryBox.isEmpty) {
      final defaultCategories = Category.getDefaultCategories();
      for (var category in defaultCategories) {
        await categoryBox.put(category.id, category);
      }
    }
  }

  // Seed default notification rules on first launch
  Future<void> _seedDefaultNotificationRules() async {
    final rulesBox = Hive.box<NotificationRule>(_notificationRulesBox);
    if (rulesBox.isEmpty) {
      final defaultRule = NotificationRule(
        keyword: 'SUPERMARKET',
        categoryId: 'cat_supermarket',
        isActive: true,
      );
      await rulesBox.put(defaultRule.id, defaultRule);
    }
  }

  static Future<void> syncFromHiveToSqlite(Box<Category> categoryBox, Box<Transaction> transactionBox) async {
    // Placeholder for SQLite sync logic.
    // Ensure this doesn't crash if SQLite is not initialized in QuickAdd mode.
    // Real implementation would go here.
  }

  // ==================== CATEGORY OPERATIONS ====================

  Future<void> addCategory(Category category) async {
    final box = Hive.box<Category>(_categoriesBox);
    await box.put(category.id, category);
  }

  Future<void> updateCategory(Category category) async {
    await addCategory(category); // Hive uses same method for update
  }

  Future<void> deleteCategory(String id) async {
    final box = Hive.box<Category>(_categoriesBox);
    await box.delete(id);
  }

  Category? getCategoryById(String id) {
    final box = Hive.box<Category>(_categoriesBox);
    return box.get(id);
  }

  List<Category> getAllCategories() {
    final box = Hive.box<Category>(_categoriesBox);
    return box.values.toList();
  }

  List<Category> getCategoriesByType(CategoryType type) {
    final box = Hive.box<Category>(_categoriesBox);
    return box.values.where((cat) => cat.type == type).toList();
  }

  // ==================== TRANSACTION OPERATIONS ====================

  Future<String> addTransaction(Transaction transaction) async {
    final box = Hive.box<Transaction>(_transactionsBox);
    await box.put(transaction.id, transaction);
    return transaction.id;
  }

  Future<void> updateTransaction(Transaction transaction) async {
    await addTransaction(transaction);
  }

  Future<void> deleteTransaction(String id) async {
    final box = Hive.box<Transaction>(_transactionsBox);
    await box.delete(id);
  }

  Transaction? getTransactionById(String id) {
    final box = Hive.box<Transaction>(_transactionsBox);
    return box.get(id);
  }

  List<Transaction> getAllTransactions() {
    final box = Hive.box<Transaction>(_transactionsBox);
    return box.values.toList();
  }

  // Get transactions for a specific month
  List<Transaction> getTransactionsForMonth(int month, int year) {
    final box = Hive.box<Transaction>(_transactionsBox);
    return box.values
        .where((txn) => txn.isInMonth(month, year))
        .toList()
      ..sort((a, b) => b.date.compareTo(a.date)); // Latest first
  }

  // Get transactions within a date range
  List<Transaction> getTransactionsInRange(DateTime start, DateTime end, {String? categoryId}) {
    final box = Hive.box<Transaction>(_transactionsBox);
    return box.values
        .where((txn) =>
            (categoryId == null || txn.categoryId == categoryId) &&
            txn.date.isAfter(start.subtract(const Duration(seconds: 1))) &&
            txn.date.isBefore(end.add(const Duration(seconds: 1))))
        .toList();
  }

  // Get transactions for current week for a specific category
  List<Transaction> getCurrentWeekTransactions(String categoryId) {
    final box = Hive.box<Transaction>(_transactionsBox);
    final now = DateTime.now();
    final weekStart = _getWeekStart(now);
    final weekEnd = weekStart.add(const Duration(days: 7));

    return box.values
        .where((txn) =>
            txn.categoryId == categoryId &&
            txn.date.isAfter(weekStart.subtract(const Duration(seconds: 1))) &&
            txn.date.isBefore(weekEnd))
        .toList();
  }

  // Helper to get Monday of current week
  DateTime _getWeekStart(DateTime date) {
    final weekday = date.weekday;
    return DateTime(date.year, date.month, date.day - (weekday - 1));
  }

  // ==================== MONTHLY BUDGET OPERATIONS ====================

  Future<void> addMonthlyBudget(MonthlyBudget budget) async {
    final box = Hive.box<MonthlyBudget>(_monthlyBudgetsBox);
    await box.put(budget.id, budget);
  }

  Future<void> updateMonthlyBudget(MonthlyBudget budget) async {
    await addMonthlyBudget(budget);
  }

  Future<void> deleteMonthlyBudget(String id) async {
    final box = Hive.box<MonthlyBudget>(_monthlyBudgetsBox);
    await box.delete(id);
  }

  MonthlyBudget? getMonthlyBudgetById(String id) {
    final box = Hive.box<MonthlyBudget>(_monthlyBudgetsBox);
    return box.get(id);
  }

  // Get or create monthly budget for a specific month
  Future<MonthlyBudget> getOrCreateMonthlyBudget(int month, int year) async {
    final box = Hive.box<MonthlyBudget>(_monthlyBudgetsBox);
    
    // Try to find existing budget
    final existing = box.values.firstWhere(
      (budget) => budget.month == month && budget.year == year,
      orElse: () => MonthlyBudget(
        id: '',
        month: 0,
        year: 0,
        createdAt: DateTime.now(),
      ),
    );

    if (existing.id.isNotEmpty) {
      return existing;
    }

    // Calculate rollover and get previous target
    double initialBalance = 0.0;
    double? previousTarget;

    int prevMonth = month - 1;
    int prevYear = year;
    if (prevMonth == 0) {
      prevMonth = 12;
      prevYear = year - 1;
    }
    
    // Check if previous budget exists
    try {
      final box = Hive.box<MonthlyBudget>(_monthlyBudgetsBox);
      final prevBudget = box.values.firstWhere(
        (b) => b.month == prevMonth && b.year == prevYear,
      );
      
      previousTarget = prevBudget.targetRemainingBalance;
      
      // Calculate previous month's final balance
      final prevBalance = getCurrentBalanceForMonth(
        prevMonth, 
        prevYear, 
        prevBudget.initialBalance
      );
      
      double target = prevBudget.targetRemainingBalance ?? 0.0;
      if (prevBalance > target) {
        initialBalance = prevBalance - target;
      } else {
        initialBalance = 0.0; 
      }
      
    } catch (_) {
      // No previous budget found, start with 0
    }

    // Create new budget for this month
    final fixedExpensesTotal = getTotalFixedExpensesForMonth();

    final newBudget = MonthlyBudget(
      id: _uuid.v4(),
      month: month,
      year: year,
      initialBalance: initialBalance,
      targetRemainingBalance: previousTarget, // Copy target
      createdAt: DateTime.now(),
      projectedFixedExpenses: fixedExpensesTotal,
    );

    await addMonthlyBudget(newBudget);
    return newBudget;
  }
  
  // Calculate rollover balance from previous month
  double calculateRolloverFromPreviousMonth(int month, int year) {
    double rollover = 0.0;
    
    int prevMonth = month - 1;
    int prevYear = year;
    if (prevMonth == 0) {
      prevMonth = 12;
      prevYear = year - 1;
    }
    
    // Check if previous budget exists
    try {
      final box = Hive.box<MonthlyBudget>(_monthlyBudgetsBox);
      final prevBudget = box.values.firstWhere(
        (b) => b.month == prevMonth && b.year == prevYear,
      );
      
      // Calculate previous month's final balance
      final prevBalance = getCurrentBalanceForMonth(
        prevMonth, 
        prevYear, 
        prevBudget.initialBalance
      );
      
      double target = prevBudget.targetRemainingBalance ?? 0.0;
      if (prevBalance > target) {
        rollover = prevBalance - target;
      } else {
        rollover = 0.0; 
      }
      
    } catch (_) {
      // No previous budget found, start with 0
    }
    
    return rollover;
  }

  List<MonthlyBudget> getAllMonthlyBudgets() {
    final box = Hive.box<MonthlyBudget>(_monthlyBudgetsBox);
    return box.values.toList()
      ..sort((a, b) {
        final dateA = DateTime(a.year, a.month);
        final dateB = DateTime(b.year, b.month);
        return dateB.compareTo(dateA); // Latest first
      });
  }

  // ==================== WEEKLY LIMIT OPERATIONS ====================

  Future<void> addWeeklyLimit(WeeklyLimit limit) async {
    final box = Hive.box<WeeklyLimit>(_weeklyLimitsBox);
    await box.put(limit.id, limit);
  }

  Future<void> updateWeeklyLimit(WeeklyLimit limit) async {
    await addWeeklyLimit(limit);
  }

  Future<void> deleteWeeklyLimit(String id) async {
    final box = Hive.box<WeeklyLimit>(_weeklyLimitsBox);
    await box.delete(id);
  }

  WeeklyLimit? getWeeklyLimitById(String id) {
    final box = Hive.box<WeeklyLimit>(_weeklyLimitsBox);
    return box.get(id);
  }

  List<WeeklyLimit> getAllWeeklyLimits() {
    final box = Hive.box<WeeklyLimit>(_weeklyLimitsBox);
    return box.values.toList();
  }

  // Get active weekly limit for a category
  WeeklyLimit? getActiveWeeklyLimitForCategory(String categoryId) {
    final box = Hive.box<WeeklyLimit>(_weeklyLimitsBox);
    return box.values.firstWhere(
      (limit) => limit.categoryId == categoryId && limit.isActive && limit.isCurrentWeek(),
      orElse: () => WeeklyLimit(
        id: '',
        categoryId: '',
        limitAmount: 0,
        weekStartDate: DateTime.now(),
        isActive: false,
      ),
    ).id.isNotEmpty
        ? box.values.firstWhere(
            (limit) => limit.categoryId == categoryId && limit.isActive && limit.isCurrentWeek(),
          )
        : null;
  }

  // ==================== MONTHLY LIMIT OPERATIONS ====================

  Future<void> addMonthlyLimit(MonthlyLimit limit) async {
    final box = Hive.box<MonthlyLimit>(_monthlyLimitsBox);
    await box.put(limit.id, limit);
  }

  Future<void> updateMonthlyLimit(MonthlyLimit limit) async {
    await addMonthlyLimit(limit);
  }

  Future<void> deleteMonthlyLimit(String id) async {
    final box = Hive.box<MonthlyLimit>(_monthlyLimitsBox);
    await box.delete(id);
  }

  MonthlyLimit? getMonthlyLimitById(String id) {
    final box = Hive.box<MonthlyLimit>(_monthlyLimitsBox);
    return box.get(id);
  }

  List<MonthlyLimit> getAllMonthlyLimits() {
    final box = Hive.box<MonthlyLimit>(_monthlyLimitsBox);
    return box.values.toList();
  }

  // Get active monthly limit for a category
  MonthlyLimit? getActiveMonthlyLimitForCategory(String categoryId) {
    final box = Hive.box<MonthlyLimit>(_monthlyLimitsBox);
    try {
      return box.values.firstWhere(
        (limit) => limit.categoryId == categoryId && limit.isActive,
      );
    } catch (_) {
      return null;
    }
  }

  // ==================== ANALYTICS HELPERS ====================

  // Calculate total income for a month
  double getTotalIncomeForMonth(int month, int year) {
    final transactions = getTransactionsForMonth(month, year);
    return transactions
        .where((txn) => txn.type == TransactionType.income)
        .fold(0.0, (sum, txn) => sum + txn.amount);
  }

  // Calculate total expense for a month
  double getTotalExpenseForMonth(int month, int year) {
    final transactions = getTransactionsForMonth(month, year);
    return transactions
        .where((txn) => txn.type == TransactionType.expense)
        .fold(0.0, (sum, txn) => sum + txn.amount);
  }

  // Calculate current balance for a month
  double getCurrentBalanceForMonth(int month, int year, double initialBalance) {
    final income = getTotalIncomeForMonth(month, year);
    final expense = getTotalExpenseForMonth(month, year);
    return initialBalance + income - expense;
  }

  // Get spending by category for a month
  Map<String, double> getSpendingByCategory(int month, int year) {
    final transactions = getTransactionsForMonth(month, year)
        .where((txn) => txn.type == TransactionType.expense);
    
    final Map<String, double> categorySpending = {};
    for (var txn in transactions) {
      categorySpending[txn.categoryId] = (categorySpending[txn.categoryId] ?? 0) + txn.amount;
    }
    return categorySpending;
  }

  // ==================== FIXED EXPENSE OPERATIONS ====================

  Future<void> addFixedExpense(FixedExpense expense) async {
    final box = Hive.box<FixedExpense>(_fixedExpensesBox);
    await box.put(expense.id, expense);
  }

  Future<void> updateFixedExpense(FixedExpense expense) async {
    await addFixedExpense(expense);
  }

  Future<void> deleteFixedExpense(String id) async {
    final box = Hive.box<FixedExpense>(_fixedExpensesBox);
    await box.delete(id);
  }

  FixedExpense? getFixedExpenseById(String id) {
    final box = Hive.box<FixedExpense>(_fixedExpensesBox);
    return box.get(id);
  }

  List<FixedExpense> getAllFixedExpenses() {
    final box = Hive.box<FixedExpense>(_fixedExpensesBox);
    return box.values.where((expense) => expense.isActive).toList();
  }

  // Get total amount of fixed expenses for a month
  double getTotalFixedExpensesForMonth() {
    final expenses = getAllFixedExpenses();
    return expenses.fold(0.0, (sum,expense) => sum + expense.amount);
  }

  // Calculate total all-time savings (Piggy Bank)
  // Sum of targets met in PAST months.
  double calculateAllTimeSavings() {
    final budgets = getAllMonthlyBudgets();
    final now = DateTime.now();
    double totalSavings = 0.0;
    
    for (var budget in budgets) {
      // Skip current month (not finished yet) and future months
      if (budget.year > now.year || (budget.year == now.year && budget.month >= now.month)) {
        continue;
      }
      
      // Calculate final balance for that month
      final balance = getCurrentBalanceForMonth(budget.month, budget.year, budget.initialBalance);
      final target = budget.targetRemainingBalance ?? 0.0;
      
      // Logic:
      // If Balance >= Target: Saved = Target.
      // If Balance < Target: Saved = 0 (Failed to save, rolled over everything presumably or just spent it).
      // Or strictly: Saved = min(Balance, Target) if Balance > 0?
      // User said: "20k to accumulations, 5k to next month".
      // If I had 10k (Target 20k).
      // Did I save 10k? Or 0? 
      // Safe bet: If I didn't reach target, I probably need that money for next month.
      // So only count "Target" if fully met? 
      // Or maybe "Savings" is just whatever WASN'T rolled over?
      // But we calculate rollover naturally.
      // Let's assume: Savings = min(max(0, balance), target).
      // If balance 25, target 20 -> Save 20.
      // If balance 10, target 20 -> Save 10.
      // If balance -5, target 20 -> Save 0.
      
      double saved = 0.0;
      if (balance > 0) {
        if (target > 0) {
           if (balance >= target) {
             saved = target;
           } else {
             saved = balance; // Saved what we could
           }
        }
      }
      totalSavings += saved;
    }
    return totalSavings;
  }

  // ==================== TEMPLATE OPERATIONS ====================

  Future<void> addTransactionTemplate(TransactionTemplate template) async {
    final box = Hive.box<TransactionTemplate>(_transactionTemplatesBox);
    await box.put(template.id, template);
  }

  Future<void> deleteTransactionTemplate(String id) async {
    final box = Hive.box<TransactionTemplate>(_transactionTemplatesBox);
    await box.delete(id);
  }

  List<TransactionTemplate> getAllTransactionTemplates() {
    final box = Hive.box<TransactionTemplate>(_transactionTemplatesBox);
    return box.values.toList();
  }

  // ==================== SAVINGS GOAL OPERATIONS ====================

  Future<void> addSavingsGoal(SavingsGoal goal) async {
    final box = Hive.box<SavingsGoal>(_savingsGoalsBox);
    await box.put(goal.id, goal);
  }

  Future<void> updateSavingsGoal(SavingsGoal goal) async {
    await addSavingsGoal(goal);
  }

  Future<void> deleteSavingsGoal(String id) async {
    final box = Hive.box<SavingsGoal>(_savingsGoalsBox);
    await box.delete(id);
  }

  SavingsGoal? getSavingsGoalById(String id) {
    final box = Hive.box<SavingsGoal>(_savingsGoalsBox);
    return box.get(id);
  }

  List<SavingsGoal> getAllSavingsGoals() {
    final box = Hive.box<SavingsGoal>(_savingsGoalsBox);
    return box.values.toList();
  }



  // ==================== CLEANUP ====================

  // ==================== FIXED EXPENSES STATUS ====================

  Future<void> setFixedExpensePaid(String id, int month, int year, bool isPaid) async {
    final box = Hive.box('fixedExpensesStatus');
    final key = '${id}_${month}_$year';
    if (isPaid) {
      await box.put(key, true);
    } else {
      await box.delete(key);
    }
  }

  bool isFixedExpensePaid(String id, int month, int year) {
    final box = Hive.box('fixedExpensesStatus');
    final key = '${id}_${month}_$year';
    return box.containsKey(key);
  }
  
  // Calculate total fixed expenses (User requested unconditional deduction)
  double getUnpaidFixedExpensesTotal(int month, int year) {
    final fixedBox = Hive.box<FixedExpense>(_fixedExpensesBox);
    final expenses = fixedBox.values.where((e) => e.isActive).toList();
    return expenses.fold(0.0, (sum, e) => sum + e.amount);
  }

  // ==================== NOTIFICATION RULE OPERATIONS ====================

  Future<void> addNotificationRule(NotificationRule rule) async {
    final box = Hive.box<NotificationRule>(_notificationRulesBox);
    await box.put(rule.id, rule);
  }

  Future<void> updateNotificationRule(NotificationRule rule) async {
    await addNotificationRule(rule);
  }

  Future<void> deleteNotificationRule(String id) async {
    final box = Hive.box<NotificationRule>(_notificationRulesBox);
    await box.delete(id);
  }

  NotificationRule? getNotificationRuleById(String id) {
    final box = Hive.box<NotificationRule>(_notificationRulesBox);
    return box.get(id);
  }

  List<NotificationRule> getAllNotificationRules() {
    final box = Hive.box<NotificationRule>(_notificationRulesBox);
    return box.values.toList();
  }

  List<NotificationRule> getActiveNotificationRules() {
    final box = Hive.box<NotificationRule>(_notificationRulesBox);
    return box.values.where((rule) => rule.isActive).toList();
  }

  // Get category ID for a keyword (returns null if not found)
  String? getCategoryForKeyword(String keyword) {
    final box = Hive.box<NotificationRule>(_notificationRulesBox);
    try {
      final rule = box.values.firstWhere(
        (rule) => rule.isActive && rule.keyword.toUpperCase() == keyword.toUpperCase(),
      );
      return rule.categoryId;
    } catch (_) {
      return null;
    }
  }

  // ==================== NOTIFICATION LOG OPERATIONS ====================

  Future<void> addNotificationLog(NotificationLog log) async {
    final box = Hive.box<NotificationLog>(_notificationLogsBox);
    
    // Keep only last 50 logs to avoid bloat
    if (box.length >= 50) {
      final oldestKey = box.keys.first;
      await box.delete(oldestKey);
    }
    
    await box.add(log);
  }

  List<NotificationLog> getRecentNotificationLogs({int limit = 20}) {
    final box = Hive.box<NotificationLog>(_notificationLogsBox);
    final logs = box.values.toList();
    logs.sort((a, b) => b.timestamp.compareTo(a.timestamp)); // Most recent first
    return logs.take(limit).toList();
  }

  Future<void> clearNotificationLogs() async {
    final box = Hive.box<NotificationLog>(_notificationLogsBox);
    await box.clear();
  }

  // ==================== CLEANUP ====================

  Future<void> close() async {
    await Hive.close();
  }
}
